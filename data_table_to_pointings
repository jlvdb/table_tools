#!/usr/bin/env python3
import argparse
import os
import shutil

import numpy as np

from table_tools import (
    load_table, read_pointing_file,
    pointings_multi_matches, pointings_no_matches, pointings_write_tables)


if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        description='Split a survey data sample into pointing samples '
                    'defined by RA/DEC cuts from a pointing file.')
    parser.add_argument(
        '-i', '--input', required=True, help='file path of input data table')
    parser.add_argument(
        '--i-format', default='fits',
        help='astropy.table format specifier of input table')
    parser.add_argument(
        '-p', '--pointings-file', required=True,
        help='file that provides pointing RA-DEC bounds in 5 columns: '
             'pointing name, RAmin, RAmax, DECmin, DECmax')
    parser.add_argument(
        '--ra', required=True, help='fits column name of RA')
    parser.add_argument(
        '--dec', required=True, help='fits column name of DEC')
    parser.add_argument(
        '--object-limit', type=int, default=1,
        help='minimum number of objects a pointing must contain in order to '
             'not be discarded')
    parser.add_argument(
        '-o', '--output', required=True,
        help='folder where the pointing data catalogues are stored '
             '(WARNING: existing contents will be erased!)')
    parser.add_argument(
        '--o-format', default='fits',
        help='astropy.table format specifier of the output table '
             '(default: %(default)s)')
    args = parser.parse_args()

    # create output folder
    if os.path.exists(args.output):
        shutil.rmtree(args.output)
    os.mkdir(args.output)

    # read the pointing defining file
    pointings = read_pointing_file(args.pointings_file)

    table = load_table(args.input, args.i_format, [args.ra, args.dec])
    ra_data = table[args.ra]
    dec_data = table[args.dec]

    # mask the table to each of the pointings
    ra_data = table[args.ra]
    dec_data = table[args.dec]
    pointing_names = sorted([
        p[0] for p in pointings])  # must keep these in order
    print("splitting data into pointings")
    pointing_mask_list = []
    for n, (pname, RAmin, RAmax, DECmin, DECmax) in enumerate(pointings, 1):
        pointing_mask_list.append((  # mask data to bounds
            (ra_data >= RAmin) & (ra_data < RAmax) &
            (dec_data >= DECmin) & (dec_data < DECmax)))
    # stack the boolean masks
    pointing_masks = np.empty(
        (len(pointing_mask_list), len(table)), dtype="bool")
    for i, mask in enumerate(pointing_mask_list):
        pointing_masks[i] = mask

    # compute global mask and check if object have multiple matches
    pointings_multi_matches(table, pointing_masks, args.output, args.o_format)
    # report the remainder that was not covered by any of the pointings
    pointings_no_matches(table, pointing_masks, args.output, args.o_format)
    # write the remaining data tables if they are not empty
    pointings_write_tables(
        table, pointing_masks, pointing_names, args.output, args.o_format,
        args.object_limit)
