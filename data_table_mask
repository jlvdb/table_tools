#!/usr/bin/env python3
import sys
import os
import argparse
import numpy as np
from multiprocessing import cpu_count
import multiprocessing
import stomp

from tools import load_table


def apply_mask(dtable):
    smap = stomp.Map(map_file)
    # check if objects fall within the mask
    mask = np.empty(len(dtable), dtype="bool")
    for i, data in enumerate(dtable):
        new_obj = stomp.WeightedAngularCoordinate(
            float(data[args.ra]), float(data[args.dec]),
            1.0, stomp.AngularCoordinate.Equatorial)
        mask[i] = smap.Contains(new_obj)
    return mask


if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        description='Mask a data table to geometry defined by a STOMP pixel '
                    'mask. The operation can be accelerated by using threads.')
    parser.add_argument(
        '-i', '--input', required=True, help='file path of input data table')
    parser.add_argument(
        '--i-format', default='fits',
        help='astropy.table format specifier of the input table')
    parser.add_argument(
        '-s', '--stomp-map', required=True,
        help='file path to stomp map that the defines the geometry')
    parser.add_argument(
        '--ra', required=True,
        help='name of the FITS column containing the RA')
    parser.add_argument(
        '--dec', required=True,
        help='name of the FITS column containing the DEC')
    parser.add_argument(
        '-o', '--output', required=True,
        help='file path of masked output data table')
    parser.add_argument(
        '--o-format', default='fits',
        help='astropy.table format specifier of the output table '
             '(default: %(default)s)')
    parser.add_argument(
        '--threads', type=int, default=cpu_count(),
        help='number of threads to use (default: %(default)s)')
    args = parser.parse_args()

    table = load_table(args.input, args.i_format, [args.ra, args.dec])
    # load stomp map
    map_file = args.stomp_map  # used globally in apply_mask()
    if not os.path.exists(map_file):
        sys.exit("ERROR: input file not found: " + map_file)
    print("load STOMP map: %s" % map_file)

    # for each thread load an instance of the STOMP map and a data chunk
    # STOMP masks cannot be pickled therefore not be shared between threads
    message = "mask data to map footprint"
    if args.threads == 1:  # don't use multiprocessing in this case
        print(message)
        mask = apply_mask(table)
    else:  # use a multiprocessing pool for the masking
        print(message + " using %d threads" % args.threads)
        # split the table into roughly equal chunks
        table_slices = []
        step = int(len(table) / args.threads) + 1
        for n in range(args.threads):
            table_slices.append(table[n * step:(n + 1) * step])
        # create a parallel pool
        with multiprocessing.Pool(args.threads) as pool:
            mask_chunks = pool.map(apply_mask, table_slices)
        mask = np.concatenate(mask_chunks)  # join the masks

    print("kept: %i of %i" % (np.count_nonzero(mask), len(table)))
    # remove masked objects
    table_masked = table[mask]

    # write to specified output path
    print("write table to: %s" % args.output)
    table_masked.write(args.output, format=args.o_format, overwrite=True)
